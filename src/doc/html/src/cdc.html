<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>src.cdc API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.cdc</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from abc import ABC, abstractmethod
import os
from datetime import datetime
import hashlib
import json


class CDC(ABC):
    &#34;&#34;&#34;The aim of this class is capture DataBase changes from t0 to t1 and send that changes to Data Lake like a files.
    It will be create a file with &#39;create_file&#39; method for every change happened on Database.
    The files will be put on a temporary directory (path of this folder will be defined on &#39;config_object&#39; parameter).
    In the end all files contained in folder will be send to Data Lake with &#39;send_to_dl&#39; method.
    If something will go wrong during execution of method, the previous state off datatlake will be preseve and another attempt will be make.
    &#34;&#34;&#34;

    def __init__(self, data_lake, data_base, config_obj:dict):
        &#34;&#34;&#34;CDC Constructor

        Args:
            data_lake ([Datalake]): Datalake object
            data_base (Databse): Database object
            config_obj (dict): Configuration object `changes_path` is path for tmp folder, `arch_type` id the architecture over dcd work &#39;log_data&#39;, &#39;registry_data&#39;
        &#34;&#34;&#34;
        self.conf=config_obj
        self.data_lake=data_lake
        self.data_base=data_base

    def send_to_dl(self) -&gt; None:
        &#34;&#34;&#34;Function that send file from tmp folder to datalake inside a transaction. If something fail during this operation Datalake is retore to the previos state, and another attempt will be make.

        Algorithm explanation
        ---------------------

        This algorithms take every file inside tmp folder and one by one is send to datalake and is save with .tmp extension.
        In the end, when all file will be copy on datalake, all file with .tmp extension will be rename with correct one.ABC
        If for any reason some file fail to send or some exceptio was rais, the operation will be interrupt and all file with .tmp extension on datalake will be deleted.
        The send operation will make another attemp until all file will be sent.
        &#34;&#34;&#34;
        while(True):
            list_file = os.listdir(self.conf[&#39;changes_path&#39;])

            for change in list_file:
                with open(&#39;{}/{}&#39;.format(self.conf[&#39;changes_path&#39;], change), &#39;r&#39;) as f:
                    self.data_lake.write(&#39;{}.tmp&#39;.format(&#39;.&#39;.join(change.split(&#39;.&#39;)[:-1])), f.read(), &#39;w&#39;)

            cnt=0
            for f in list_file:
                if&#39;{}.tmp&#39;.format(&#39;.&#39;.join(f.split(&#39;.&#39;)[:-1])) in self.data_lake.ls(): cnt+=1

            if cnt!=len(list_file):
                for f in list_file:
                    self.data_lake.delete(&#39;{}.tmp&#39;.format(&#39;.&#39;.join(f.split(&#39;.&#39;)[:-1])))
            else:
                for f in list_file:
                    self.data_lake.rename(&#39;{}.tmp&#39;.format(&#39;.&#39;.join(f.split(&#39;.&#39;)[:-1])), f)

                files = os.listdir(self.conf[&#39;changes_path&#39;])

                for f in files:
                    os.remove(&#39;{}/{}&#39;.format(self.conf[&#39;changes_path&#39;],f))
                break

    @abstractmethod
    def file_struct(self, file_name:str, value:dict, operation:str=None) -&gt; str:
        &#34;&#34;&#34;This method allow to make a personal file structure, that will be save on Datalake

        Args:
            file_name (str):
            value (dict): the value of the change captured over db. If operation is `DELETE` value will be `None`
            operation (str, optional): Type of operation that cause a change over database. Possible value `INSERT`, `UPDATE`, `DELETE`. Defaults to None.

        Raises:
            NotImplementedError: This method must be implemented on concreate implementation of class.

        Returns:
            str: that reflect file structure
        &#34;&#34;&#34;
        raise NotImplementedError

    def create_file(self, file_name:str, value:dict, operation:str=None) -&gt; None:
        &#34;&#34;&#34;This class call `file_struct` method, and save a file with capure changes on temporary folder.

        Args:
            file_name (str):
            value (dict): the value of the change captured over db. If operation is `DELETE` value will be `None`
            operation (str, optional): Type of operation that cause a change over database. Possible value `INSERT`, `UPDATE`, `DELETE`. Defaults to None.

        Raises:
            NotImplementedError: This method must be implemented on concreate implementation of class.
        &#34;&#34;&#34;
        path = self.file_struct(file_name, value, operation)
        os.rename(path, &#39;./{}/{}&#39;.format(self.conf[&#39;changes_path&#39;], path))

    def __find(self, hash, l, t):
        &#34;&#34;&#34;Private class method use to find a hash inside a list of dict

        Args:
            hash (str): hash value
            l ([type]): list of dict
            t ([type]): key value

        Returns:
            [bool]: True if element is find, else False
        &#34;&#34;&#34;
        for i in l:
            if(i[t] == hash): return True
        return False

    def __registry_data(self, table_name:str) -&gt; None:
        &#34;&#34;&#34;[summary]

        Args:
            table_name (str): [description]
        &#34;&#34;&#34;
        sync=[]
        try:
            sync = json.loads(self.data_lake.read(&#39;sync.json&#39;))
        except FileNotFoundError:
            pass

        db_keys=[]
        new_sync=[]
        db_data = self.data_base.exec(&#39;SELECT * FROM {}&#39;.format(table_name))

        for data in db_data:
            _khash = str(hashlib.sha256(str.encode(&#39;,&#39;.join([v for (k,v) in data[&#39;keys&#39;].items()]))).hexdigest())
            _hash = str(hashlib.sha256(str.encode(&#39;,&#39;.join([v for (k,v) in data[&#39;values&#39;].items()]))).hexdigest())
            db_keys.append(_khash)

            if(not self.__find(_khash, sync, &#39;khash&#39;)):
                self.create_file(str(datetime.now()), {_hash: data[&#39;keys&#39;], _khash: data[&#39;values&#39;]}, &#39;insert&#39;)
            else:
                if(self.__find(_khash, sync, &#39;khash&#39;) and (not  self.__find(_hash, sync, &#39;hash&#39;))):
                    self.create_file(str(datetime.now()), {_hash: data[&#39;keys&#39;], _khash: data[&#39;values&#39;]}, &#39;update&#39;)
            new_sync.append({&#39;khash&#39;: _khash, &#39;hash&#39;: _hash})


        if(sync != []):
            delete_row = set([i[&#39;khash&#39;] for i in sync]).difference(set(db_keys))
            for delete in [i for i in sync if i[&#39;khash&#39;] in delete_row]:
                self.create_file(datetime.now(), {delete[&#39;khash&#39;]: None, delete[&#39;hash&#39;]: None}, &#39;delete&#39;)

        self.data_lake.write(&#39;sync.json&#39;, json.dumps(new_sync), &#39;w&#39;)

    def __log_data(self, table_name:str) -&gt; None:
        &#34;&#34;&#34;[summary]

        Args:
            table_name (str): [description]
        &#34;&#34;&#34;
        sync = self.data_lake.read(&#39;sync.json&#39;)
        db_data = self.data_base.exec(&#39;SELECT * FROM {} WHERE {} &gt; {}&#39;.format(table_name, sync[&#39;time_column&#39;], sync[&#39;last_value&#39;]))

        for data in db_data:
            self.create_file(datetime.now(), data)

    def capture_changes(self, table_name:str)-&gt; None:
        &#34;&#34;&#34;This method call `log_data` or `registry_data` depends on architecture declared on `configuration object`

        Args:
            table_name (str): name of table over capture the changes
        &#34;&#34;&#34;
        os.mkdir(self.conf[&#39;changes_path&#39;])
        if(self.conf[&#39;arch_type&#39;] == &#39;log_data&#39;): self.__log_data(table_name)
        else: self.__registry_data(table_name)
        os.remove
        self.send_to_dl()
        os.rmdir(self.conf[&#39;changes_path&#39;])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.cdc.CDC"><code class="flex name class">
<span>class <span class="ident">CDC</span></span>
<span>(</span><span>data_lake, data_base, config_obj: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>The aim of this class is capture DataBase changes from t0 to t1 and send that changes to Data Lake like a files.
It will be create a file with 'create_file' method for every change happened on Database.
The files will be put on a temporary directory (path of this folder will be defined on 'config_object' parameter).
In the end all files contained in folder will be send to Data Lake with 'send_to_dl' method.
If something will go wrong during execution of method, the previous state off datatlake will be preseve and another attempt will be make.</p>
<p>CDC Constructor</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_lake</code></strong> :&ensp;<code>[Datalake]</code></dt>
<dd>Datalake object</dd>
<dt><strong><code>data_base</code></strong> :&ensp;<code>Databse</code></dt>
<dd>Database object</dd>
<dt><strong><code>config_obj</code></strong> :&ensp;<code>dict</code></dt>
<dd>Configuration object <code>changes_path</code> is path for tmp folder, <code>arch_type</code> id the architecture over dcd work 'log_data', 'registry_data'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CDC(ABC):
    &#34;&#34;&#34;The aim of this class is capture DataBase changes from t0 to t1 and send that changes to Data Lake like a files.
    It will be create a file with &#39;create_file&#39; method for every change happened on Database.
    The files will be put on a temporary directory (path of this folder will be defined on &#39;config_object&#39; parameter).
    In the end all files contained in folder will be send to Data Lake with &#39;send_to_dl&#39; method.
    If something will go wrong during execution of method, the previous state off datatlake will be preseve and another attempt will be make.
    &#34;&#34;&#34;

    def __init__(self, data_lake, data_base, config_obj:dict):
        &#34;&#34;&#34;CDC Constructor

        Args:
            data_lake ([Datalake]): Datalake object
            data_base (Databse): Database object
            config_obj (dict): Configuration object `changes_path` is path for tmp folder, `arch_type` id the architecture over dcd work &#39;log_data&#39;, &#39;registry_data&#39;
        &#34;&#34;&#34;
        self.conf=config_obj
        self.data_lake=data_lake
        self.data_base=data_base

    def send_to_dl(self) -&gt; None:
        &#34;&#34;&#34;Function that send file from tmp folder to datalake inside a transaction. If something fail during this operation Datalake is retore to the previos state, and another attempt will be make.

        Algorithm explanation
        ---------------------

        This algorithms take every file inside tmp folder and one by one is send to datalake and is save with .tmp extension.
        In the end, when all file will be copy on datalake, all file with .tmp extension will be rename with correct one.ABC
        If for any reason some file fail to send or some exceptio was rais, the operation will be interrupt and all file with .tmp extension on datalake will be deleted.
        The send operation will make another attemp until all file will be sent.
        &#34;&#34;&#34;
        while(True):
            list_file = os.listdir(self.conf[&#39;changes_path&#39;])

            for change in list_file:
                with open(&#39;{}/{}&#39;.format(self.conf[&#39;changes_path&#39;], change), &#39;r&#39;) as f:
                    self.data_lake.write(&#39;{}.tmp&#39;.format(&#39;.&#39;.join(change.split(&#39;.&#39;)[:-1])), f.read(), &#39;w&#39;)

            cnt=0
            for f in list_file:
                if&#39;{}.tmp&#39;.format(&#39;.&#39;.join(f.split(&#39;.&#39;)[:-1])) in self.data_lake.ls(): cnt+=1

            if cnt!=len(list_file):
                for f in list_file:
                    self.data_lake.delete(&#39;{}.tmp&#39;.format(&#39;.&#39;.join(f.split(&#39;.&#39;)[:-1])))
            else:
                for f in list_file:
                    self.data_lake.rename(&#39;{}.tmp&#39;.format(&#39;.&#39;.join(f.split(&#39;.&#39;)[:-1])), f)

                files = os.listdir(self.conf[&#39;changes_path&#39;])

                for f in files:
                    os.remove(&#39;{}/{}&#39;.format(self.conf[&#39;changes_path&#39;],f))
                break

    @abstractmethod
    def file_struct(self, file_name:str, value:dict, operation:str=None) -&gt; str:
        &#34;&#34;&#34;This method allow to make a personal file structure, that will be save on Datalake

        Args:
            file_name (str):
            value (dict): the value of the change captured over db. If operation is `DELETE` value will be `None`
            operation (str, optional): Type of operation that cause a change over database. Possible value `INSERT`, `UPDATE`, `DELETE`. Defaults to None.

        Raises:
            NotImplementedError: This method must be implemented on concreate implementation of class.

        Returns:
            str: that reflect file structure
        &#34;&#34;&#34;
        raise NotImplementedError

    def create_file(self, file_name:str, value:dict, operation:str=None) -&gt; None:
        &#34;&#34;&#34;This class call `file_struct` method, and save a file with capure changes on temporary folder.

        Args:
            file_name (str):
            value (dict): the value of the change captured over db. If operation is `DELETE` value will be `None`
            operation (str, optional): Type of operation that cause a change over database. Possible value `INSERT`, `UPDATE`, `DELETE`. Defaults to None.

        Raises:
            NotImplementedError: This method must be implemented on concreate implementation of class.
        &#34;&#34;&#34;
        path = self.file_struct(file_name, value, operation)
        os.rename(path, &#39;./{}/{}&#39;.format(self.conf[&#39;changes_path&#39;], path))

    def __find(self, hash, l, t):
        &#34;&#34;&#34;Private class method use to find a hash inside a list of dict

        Args:
            hash (str): hash value
            l ([type]): list of dict
            t ([type]): key value

        Returns:
            [bool]: True if element is find, else False
        &#34;&#34;&#34;
        for i in l:
            if(i[t] == hash): return True
        return False

    def __registry_data(self, table_name:str) -&gt; None:
        &#34;&#34;&#34;[summary]

        Args:
            table_name (str): [description]
        &#34;&#34;&#34;
        sync=[]
        try:
            sync = json.loads(self.data_lake.read(&#39;sync.json&#39;))
        except FileNotFoundError:
            pass

        db_keys=[]
        new_sync=[]
        db_data = self.data_base.exec(&#39;SELECT * FROM {}&#39;.format(table_name))

        for data in db_data:
            _khash = str(hashlib.sha256(str.encode(&#39;,&#39;.join([v for (k,v) in data[&#39;keys&#39;].items()]))).hexdigest())
            _hash = str(hashlib.sha256(str.encode(&#39;,&#39;.join([v for (k,v) in data[&#39;values&#39;].items()]))).hexdigest())
            db_keys.append(_khash)

            if(not self.__find(_khash, sync, &#39;khash&#39;)):
                self.create_file(str(datetime.now()), {_hash: data[&#39;keys&#39;], _khash: data[&#39;values&#39;]}, &#39;insert&#39;)
            else:
                if(self.__find(_khash, sync, &#39;khash&#39;) and (not  self.__find(_hash, sync, &#39;hash&#39;))):
                    self.create_file(str(datetime.now()), {_hash: data[&#39;keys&#39;], _khash: data[&#39;values&#39;]}, &#39;update&#39;)
            new_sync.append({&#39;khash&#39;: _khash, &#39;hash&#39;: _hash})


        if(sync != []):
            delete_row = set([i[&#39;khash&#39;] for i in sync]).difference(set(db_keys))
            for delete in [i for i in sync if i[&#39;khash&#39;] in delete_row]:
                self.create_file(datetime.now(), {delete[&#39;khash&#39;]: None, delete[&#39;hash&#39;]: None}, &#39;delete&#39;)

        self.data_lake.write(&#39;sync.json&#39;, json.dumps(new_sync), &#39;w&#39;)

    def __log_data(self, table_name:str) -&gt; None:
        &#34;&#34;&#34;[summary]

        Args:
            table_name (str): [description]
        &#34;&#34;&#34;
        sync = self.data_lake.read(&#39;sync.json&#39;)
        db_data = self.data_base.exec(&#39;SELECT * FROM {} WHERE {} &gt; {}&#39;.format(table_name, sync[&#39;time_column&#39;], sync[&#39;last_value&#39;]))

        for data in db_data:
            self.create_file(datetime.now(), data)

    def capture_changes(self, table_name:str)-&gt; None:
        &#34;&#34;&#34;This method call `log_data` or `registry_data` depends on architecture declared on `configuration object`

        Args:
            table_name (str): name of table over capture the changes
        &#34;&#34;&#34;
        os.mkdir(self.conf[&#39;changes_path&#39;])
        if(self.conf[&#39;arch_type&#39;] == &#39;log_data&#39;): self.__log_data(table_name)
        else: self.__registry_data(table_name)
        os.remove
        self.send_to_dl()
        os.rmdir(self.conf[&#39;changes_path&#39;])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.cdc.CDC.capture_changes"><code class="name flex">
<span>def <span class="ident">capture_changes</span></span>(<span>self, table_name: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>This method call <code>log_data</code> or <code>registry_data</code> depends on architecture declared on <code>configuration object</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>table_name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of table over capture the changes</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def capture_changes(self, table_name:str)-&gt; None:
    &#34;&#34;&#34;This method call `log_data` or `registry_data` depends on architecture declared on `configuration object`

    Args:
        table_name (str): name of table over capture the changes
    &#34;&#34;&#34;
    os.mkdir(self.conf[&#39;changes_path&#39;])
    if(self.conf[&#39;arch_type&#39;] == &#39;log_data&#39;): self.__log_data(table_name)
    else: self.__registry_data(table_name)
    os.remove
    self.send_to_dl()
    os.rmdir(self.conf[&#39;changes_path&#39;])</code></pre>
</details>
</dd>
<dt id="src.cdc.CDC.create_file"><code class="name flex">
<span>def <span class="ident">create_file</span></span>(<span>self, file_name: str, value: dict, operation: str = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>This class call <code>file_struct</code> method, and save a file with capure changes on temporary folder.</p>
<h2 id="args">Args</h2>
<dl>
<dt>file_name (str):</dt>
<dt><strong><code>value</code></strong> :&ensp;<code>dict</code></dt>
<dd>the value of the change captured over db. If operation is <code>DELETE</code> value will be <code>None</code></dd>
<dt><strong><code>operation</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Type of operation that cause a change over database. Possible value <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>. Defaults to None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>This method must be implemented on concreate implementation of class.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_file(self, file_name:str, value:dict, operation:str=None) -&gt; None:
    &#34;&#34;&#34;This class call `file_struct` method, and save a file with capure changes on temporary folder.

    Args:
        file_name (str):
        value (dict): the value of the change captured over db. If operation is `DELETE` value will be `None`
        operation (str, optional): Type of operation that cause a change over database. Possible value `INSERT`, `UPDATE`, `DELETE`. Defaults to None.

    Raises:
        NotImplementedError: This method must be implemented on concreate implementation of class.
    &#34;&#34;&#34;
    path = self.file_struct(file_name, value, operation)
    os.rename(path, &#39;./{}/{}&#39;.format(self.conf[&#39;changes_path&#39;], path))</code></pre>
</details>
</dd>
<dt id="src.cdc.CDC.file_struct"><code class="name flex">
<span>def <span class="ident">file_struct</span></span>(<span>self, file_name: str, value: dict, operation: str = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>This method allow to make a personal file structure, that will be save on Datalake</p>
<h2 id="args">Args</h2>
<dl>
<dt>file_name (str):</dt>
<dt><strong><code>value</code></strong> :&ensp;<code>dict</code></dt>
<dd>the value of the change captured over db. If operation is <code>DELETE</code> value will be <code>None</code></dd>
<dt><strong><code>operation</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Type of operation that cause a change over database. Possible value <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>. Defaults to None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>This method must be implemented on concreate implementation of class.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>that reflect file structure</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def file_struct(self, file_name:str, value:dict, operation:str=None) -&gt; str:
    &#34;&#34;&#34;This method allow to make a personal file structure, that will be save on Datalake

    Args:
        file_name (str):
        value (dict): the value of the change captured over db. If operation is `DELETE` value will be `None`
        operation (str, optional): Type of operation that cause a change over database. Possible value `INSERT`, `UPDATE`, `DELETE`. Defaults to None.

    Raises:
        NotImplementedError: This method must be implemented on concreate implementation of class.

    Returns:
        str: that reflect file structure
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="src.cdc.CDC.send_to_dl"><code class="name flex">
<span>def <span class="ident">send_to_dl</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Function that send file from tmp folder to datalake inside a transaction. If something fail during this operation Datalake is retore to the previos state, and another attempt will be make.</p>
<h2 id="algorithm-explanation">Algorithm Explanation</h2>
<p>This algorithms take every file inside tmp folder and one by one is send to datalake and is save with .tmp extension.
In the end, when all file will be copy on datalake, all file with .tmp extension will be rename with correct one.ABC
If for any reason some file fail to send or some exceptio was rais, the operation will be interrupt and all file with .tmp extension on datalake will be deleted.
The send operation will make another attemp until all file will be sent.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_to_dl(self) -&gt; None:
    &#34;&#34;&#34;Function that send file from tmp folder to datalake inside a transaction. If something fail during this operation Datalake is retore to the previos state, and another attempt will be make.

    Algorithm explanation
    ---------------------

    This algorithms take every file inside tmp folder and one by one is send to datalake and is save with .tmp extension.
    In the end, when all file will be copy on datalake, all file with .tmp extension will be rename with correct one.ABC
    If for any reason some file fail to send or some exceptio was rais, the operation will be interrupt and all file with .tmp extension on datalake will be deleted.
    The send operation will make another attemp until all file will be sent.
    &#34;&#34;&#34;
    while(True):
        list_file = os.listdir(self.conf[&#39;changes_path&#39;])

        for change in list_file:
            with open(&#39;{}/{}&#39;.format(self.conf[&#39;changes_path&#39;], change), &#39;r&#39;) as f:
                self.data_lake.write(&#39;{}.tmp&#39;.format(&#39;.&#39;.join(change.split(&#39;.&#39;)[:-1])), f.read(), &#39;w&#39;)

        cnt=0
        for f in list_file:
            if&#39;{}.tmp&#39;.format(&#39;.&#39;.join(f.split(&#39;.&#39;)[:-1])) in self.data_lake.ls(): cnt+=1

        if cnt!=len(list_file):
            for f in list_file:
                self.data_lake.delete(&#39;{}.tmp&#39;.format(&#39;.&#39;.join(f.split(&#39;.&#39;)[:-1])))
        else:
            for f in list_file:
                self.data_lake.rename(&#39;{}.tmp&#39;.format(&#39;.&#39;.join(f.split(&#39;.&#39;)[:-1])), f)

            files = os.listdir(self.conf[&#39;changes_path&#39;])

            for f in files:
                os.remove(&#39;{}/{}&#39;.format(self.conf[&#39;changes_path&#39;],f))
            break</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.cdc.CDC" href="#src.cdc.CDC">CDC</a></code></h4>
<ul class="">
<li><code><a title="src.cdc.CDC.capture_changes" href="#src.cdc.CDC.capture_changes">capture_changes</a></code></li>
<li><code><a title="src.cdc.CDC.create_file" href="#src.cdc.CDC.create_file">create_file</a></code></li>
<li><code><a title="src.cdc.CDC.file_struct" href="#src.cdc.CDC.file_struct">file_struct</a></code></li>
<li><code><a title="src.cdc.CDC.send_to_dl" href="#src.cdc.CDC.send_to_dl">send_to_dl</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>